<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="referrer" content="no-referrer-when-downgrade">
    

    <title>kubelet事件处理机制详解 | zoux的博客</title>
    <meta property="og:title" content="kubelet事件处理机制详解 - zoux的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2021-06-26T00:32:20&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2021-06-26T00:32:20&#43;08:00'>
        
    <meta name="Keywords" content="golang,go语言,go语言笔记,zoux,k8s,Kubernetes,docker,kubeflow">
    <meta name="description" content="kubelet事件处理机制详解">
        
    <meta name="author" content="zoux">
    <meta property="og:url" content="https://zoux86.github.io/post/2020-6-26-kubelet%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/">
    <link rel="shortcut icon" href='/favicon.ico'  type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zoux86.github.io/">
                        zoux的博客
                    </a>
                
                <p class="description">对Go语言(golang)、k8s、kubeflow，容器云，云原生感兴趣</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://zoux86.github.io/">首页</a>
                    
                    <a  href="https://zoux86.github.io/tools/" title="工具">工具</a>
                    
                    <a  href="https://zoux86.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="https://zoux86.github.io/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">kubelet事件处理机制详解</h1>
        </header>
        <date class="post-meta meta-date">
            2021年6月26日
        </date>
        
        <div class="post-meta">
            <span>|</span>
            
            <span class="meta-category"><a href='/categories/k8s'>k8s</a></span>
            
        </div>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>本文从kubelet组件源码角度入手，分析kubelet中的事件处理机制</p>

<h3 id="1-kubelet事件处理机制入口">1. kubelet事件处理机制入口</h3>
<pre><code>// RunKubelet is responsible for setting up and running a kubelet.  It is used in three different applications:
//   1 Integration tests
//   2 Kubelet binary
//   3 Standalone &#39;kubernetes&#39; binary
// Eventually, #2 will be replaced with instances of #3

// 第一步调用 makeEventRecorder，这里就表示 事件处理机制 产生了
func RunKubelet(kubeServer *options.KubeletServer, kubeDeps *kubelet.Dependencies, runOnce bool) error {
	...
	// Setup event recorder if required.
	makeEventRecorder(kubeDeps, nodeName)
  ...
}</code></pre>
<p>makeEventRecorder主要做了以下事情:</p>

<p>（1）初始化 EventBroadcaster</p>

<p>（2）初始化 Recorder</p>

<p>（3）记录文件到本地</p>

<p>（4）上传事件到apiserver</p>
<pre><code>// makeEventRecorder sets up kubeDeps.Recorder if it&#39;s nil. It&#39;s a no-op otherwise.
func makeEventRecorder(kubeDeps *kubelet.Dependencies, nodeName types.NodeName) {
	if kubeDeps.Recorder != nil {
		return
	}
  // 初始化 EventBroadcaster
	eventBroadcaster := record.NewBroadcaster()
  // 初始化 Recorder
	kubeDeps.Recorder = eventBroadcaster.NewRecorder(legacyscheme.Scheme, v1.EventSource{Component: componentKubelet, Host: string(nodeName)})
  // 记录文件到本地
	eventBroadcaster.StartLogging(glog.V(3).Infof)
	
	// 上传事件到apiserver
	if kubeDeps.EventClient != nil {
		glog.V(4).Infof(&#34;zoux-test Sending events to api server.&#34;)
		eventBroadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl{Interface: kubeDeps.EventClient.Events(&#34;&#34;)})
	} else {
		glog.Warning(&#34;zoux-test No api server defined - no events will be sent to API server.&#34;)
	}
}</code></pre>
<p>接下来根据这四个点进行深入</p>

<p><br></p>

<h3 id="2-初始化-eventbroadcaster">2 初始化 EventBroadcaster</h3>

<p>初始化 EventBroadcaster就是生成了一个eventBroadcasterImpl对象。该对象是NewBroadcaster的实现类。</p>
<pre><code>// Creates a new event broadcaster.
func NewBroadcaster() EventBroadcaster {
	return &amp;eventBroadcasterImpl{watch.NewBroadcaster(maxQueuedEvents, watch.DropIfChannelFull), defaultSleepDuration}
}

const maxTriesPerEvent = 12
var defaultSleepDuration = 10 * time.Second
const maxQueuedEvents = 1000


// EventBroadcaster knows how to receive events and send them to any EventSink, watcher, or log.
type EventBroadcaster interface {
	// StartEventWatcher starts sending events received from this EventBroadcaster to the given
	// event handler function. The return value can be ignored or used to stop recording, if
	// desired.
	StartEventWatcher(eventHandler func(*v1.Event)) watch.Interface

	// StartRecordingToSink starts sending events received from this EventBroadcaster to the given
	// sink. The return value can be ignored or used to stop recording, if desired.
	StartRecordingToSink(sink EventSink) watch.Interface

	// StartLogging starts sending events received from this EventBroadcaster to the given logging
	// function. The return value can be ignored or used to stop recording, if desired.
	StartLogging(logf func(format string, args ...interface{})) watch.Interface

	// NewRecorder returns an EventRecorder that can be used to send events to this EventBroadcaster
	// with the event source set to the given event source.
	NewRecorder(scheme *runtime.Scheme, source v1.EventSource) EventRecorder
}</code></pre>
<p>NewBroadcaster对象是个接口类型，该接口有以下四个方法：</p>

<ul>
<li>StartEventWatcher() ： 接收各模块产生的 events，根据调用者的处理函数就行事件处理。</li>
<li>StartRecordingToSink() ： 调用 StartEventWatcher() 接收 events，并将收到的 events 发送到 apiserver</li>
<li>StartLogging() ：也是调用 StartEventWatcher() 接收 events，然后保存 events 到日志</li>
<li>NewRecorder() ：会创建一个指定 EventSource 的 EventRecorder，EventSource 指明了哪个节点的哪个组件</li>
</ul>

<p>这个有点类型于设计模式中的<strong>观察者模式</strong></p>

<p>Broadcaster 是一个中心，它有俩个处理事件的函数：</p>

<p>第一个是StartLogging函数，这个就是直接打印处理日志。</p>

<p>第二个就是StartRecordingToSink函数，这个就是将事件发送到apiserver。</p>

<p>有了处理方式，接下来就是事件从哪里来的问题。NewRecorder就是干这个的。</p>

<p>NewRecorder 就是一个一个客户端，这个客户端通过chan忘中心发送事件用于处理。</p>

<p><br></p>

<p>接下来就是看eventBroadcasterImpl这个对象是怎样实现这套机制(四个函数)的。</p>

<p><br></p>

<h4 id="2-1-newrecorder">2.1 NewRecorder</h4>

<p>作用：生成一个事件客户端。比如kubelet的 statusManager就是一个客户端。它只负责产生事件，并且将事件送到 kubelet这个broadcaster就行。</p>

<p>NewRecorder其实返回一个recorderImpl对象。</p>
<pre><code>// NewRecorder returns an EventRecorder that records events with the given event source.
func (eventBroadcaster *eventBroadcasterImpl) NewRecorder(scheme *runtime.Scheme, source v1.EventSource) EventRecorder {
   return &amp;recorderImpl{scheme, source, eventBroadcaster.Broadcaster, clock.RealClock{}}
}


type recorderImpl struct {
	scheme *runtime.Scheme
	source v1.EventSource
	*watch.Broadcaster
	clock clock.Clock
}</code></pre>
<p><br></p>

<p>recorderImpl这个对象一个核心函数就是generateEvent。</p>
<pre><code>func (recorder *recorderImpl) generateEvent(object runtime.Object, annotations map[string]string, timestamp metav1.Time, eventtype, reason, message string) {
	ref, err := ref.GetReference(recorder.scheme, object)
	if err != nil {
		glog.Errorf(&#34;Could not construct reference to: &#39;%#v&#39; due to: &#39;%v&#39;. Will not report event: &#39;%v&#39; &#39;%v&#39; &#39;%v&#39;&#34;, object, err, eventtype, reason, message)
		return
	}

	if !validateEventType(eventtype) {
		glog.Errorf(&#34;Unsupported event type: &#39;%v&#39;&#34;, eventtype)
		return
	}

	event := recorder.makeEvent(ref, annotations, eventtype, reason, message)
	event.Source = recorder.source
 
  // 这里对事件进行了发送
	go func() {
		// NOTE: events should be a non-blocking operation
		defer utilruntime.HandleCrash()
		recorder.Action(watch.Added, event)
	}()
}

// 往Broadcaster发送事件
// Action distributes the given event among all watchers.
func (m *Broadcaster) Action(action EventType, obj runtime.Object) {
	m.incoming &lt;- Event{action, obj}
}</code></pre>
<p>其他的函数，Event，AnnotatedEventf等最终都是调用generateEvent，发送事件到Broadcaster的chan。</p>
<pre><code>func (recorder *recorderImpl) Event(object runtime.Object, eventtype, reason, message string) {
	recorder.generateEvent(object, nil, metav1.Now(), eventtype, reason, message)
}


func (recorder *recorderImpl) Eventf(object runtime.Object, eventtype, reason, messageFmt string, args ...interface{}) {
	recorder.Event(object, eventtype, reason, fmt.Sprintf(messageFmt, args...))
}


func (recorder *recorderImpl) PastEventf(object runtime.Object, timestamp metav1.Time, eventtype, reason, messageFmt string, args ...interface{}) {
	recorder.generateEvent(object, nil, timestamp, eventtype, reason, fmt.Sprintf(messageFmt, args...))
}


func (recorder *recorderImpl) AnnotatedEventf(object runtime.Object, annotations map[string]string, eventtype, reason, messageFmt string, args ...interface{}) {
	recorder.generateEvent(object, annotations, metav1.Now(), eventtype, reason, fmt.Sprintf(messageFmt, args...))
}


func (recorder *recorderImpl) makeEvent(ref *v1.ObjectReference, annotations map[string]string, eventtype, reason, message string) *v1.Event {
	t := metav1.Time{Time: recorder.clock.Now()}
	namespace := ref.Namespace
	if namespace == &#34;&#34; {
		namespace = metav1.NamespaceDefault
	}
	return &amp;v1.Event{
		ObjectMeta: metav1.ObjectMeta{
			Name:        fmt.Sprintf(&#34;%v.%x&#34;, ref.Name, t.UnixNano()),
			Namespace:   namespace,
			Annotations: annotations,
		},
		InvolvedObject: *ref,
		Reason:         reason,
		Message:        message,
		FirstTimestamp: t,
		LastTimestamp:  t,
		Count:          1,
		Type:           eventtype,
	}
}</code></pre>
<p><br></p>

<p>了解了客户端是如何发送事件到事件中心的，接下来看看事件中心是如何处理的。</p>

<h4 id="2-2-starteventwatcher">2.2 StartEventWatcher</h4>

<p>从这个函数的实现很明显可以看出来，这个函数就是变量 一个channel，然后调用处理函数进行处理。</p>
<pre><code>// StartEventWatcher starts sending events received from this EventBroadcaster to the given event handler function.
// The return value can be ignored or used to stop recording, if desired.
func (eventBroadcaster *eventBroadcasterImpl) StartEventWatcher(eventHandler func(*v1.Event)) watch.Interface {
	watcher := eventBroadcaster.Watch()
	go func() {
		defer utilruntime.HandleCrash()
		for watchEvent := range watcher.ResultChan() {
			event, ok := watchEvent.Object.(*v1.Event)
			if !ok {
				// This is all local, so there&#39;s no reason this should
				// ever happen.
				continue
			}
			eventHandler(event)
		}
	}()
	return watcher
}</code></pre>
<h4 id="2-3-startlogging">2.3 StartLogging</h4>

<p>调用 StartEventWatcher() 接收 events，并将收到的 events 打印出来</p>
<pre><code>// StartLogging starts sending events received from this EventBroadcaster to the given logging function.
// The return value can be ignored or used to stop recording, if desired.
func (eventBroadcaster *eventBroadcasterImpl) StartLogging(logf func(format string, args ...interface{})) watch.Interface {
   return eventBroadcaster.StartEventWatcher(
      func(e *v1.Event) {
         logf(&#34;zoux-test Event(%#v): type: &#39;%v&#39; reason: &#39;%v&#39; %v&#34;, e.InvolvedObject, e.Type, e.Reason, e.Message)
      })
}</code></pre>
<p>例如在kubelet的日志中：</p>
<pre><code>I0626 05:58:27.213752   36267 server.go:460] zoux-test Event(v1.ObjectReference{Kind:&#34;Node&#34;, Namespace:&#34;&#34;, Name:&#34;10.212.1.4&#34;, UID:&#34;10.212.1.4&#34;, APIVersion:&#34;&#34;, ResourceVersion:&#34;&#34;, FieldPath:&#34;&#34;}): type: &#39;Warning&#39; reason: &#39;MissingClusterDNS&#39; kubelet does not have ClusterDNS IP configured and cannot create Pod using &#34;ClusterFirst&#34; policy. Falling back to &#34;Default&#34; policy.</code></pre>
<h4 id="2-4-startrecordingtosink">2.4 StartRecordingToSink</h4>

<p>调用 StartEventWatcher() 接收 events，并将收到的 events 发送到 apiserver</p>

<p>可以看出来StartEventWatcher的参数是一个函数。recordToSink</p>
<pre><code>// StartRecordingToSink starts sending events received from the specified eventBroadcaster to the given sink.
// The return value can be ignored or used to stop recording, if desired.
// TODO: make me an object with parameterizable queue length and retry interval
func (eventBroadcaster *eventBroadcasterImpl) StartRecordingToSink(sink EventSink) watch.Interface {
	// The default math/rand package functions aren&#39;t thread safe, so create a
	// new Rand object for each StartRecording call.
	randGen := rand.New(rand.NewSource(time.Now().UnixNano()))
	eventCorrelator := NewEventCorrelator(clock.RealClock{})
	return eventBroadcaster.StartEventWatcher(
		func(event *v1.Event) {
			recordToSink(sink, event, eventCorrelator, randGen, eventBroadcaster.sleepDuration)
		})
}</code></pre>
<p>这里每个事件的处理就是调用 recordToSink 函数进行处理</p>

<p><br></p>

<h3 id="3-上传事件到apiserver-recordtosink">3.上传事件到apiserver-recordToSink</h3>

<p>总结起来分为以下三步：</p>

<p>（1）对事件进行聚合</p>

<p>（2）通过令牌桶算法对事件发送速度进行控制</p>

<p>（3）调用rest-api进行事件发送</p>
<pre><code>func recordToSink(sink EventSink, event *v1.Event, eventCorrelator *EventCorrelator, randGen *rand.Rand, sleepDuration time.Duration) {
	// Make a copy before modification, because there could be multiple listeners.
	// Events are safe to copy like this.
	eventCopy := *event
	event = &amp;eventCopy
	glog.Errorf(&#34;zoux-test event is &#39;%#v&#39;&#34;, event)
	// 对事件进行聚合和获取令牌
	result, err := eventCorrelator.EventCorrelate(event)
	if err != nil {
		utilruntime.HandleError(err)
	}
	glog.Errorf(&#34;zoux-test result is &#39;%#v&#39;&#34;, result)
	// 如果没有获得令牌就直接跳过
	if result.Skip {
		glog.Errorf(&#34;zoux-test event &#39;%#v&#39; is Skipped&#34;,event)
		return
	}
	// 最多重试12次， const maxTriesPerEvent = 12
	tries := 0
	for {
		glog.Errorf(&#34;zoux-test starting send event &#39;%#v&#39; &#34;,event)
		// 上传到apiserver
		if recordEvent(sink, result.Event, result.Patch, result.Event.Count &gt; 1, eventCorrelator) {
			break
		}
		glog.Errorf(&#34;zoux-test starting send event  failed&#39;%#v&#39; &#34;,event)
		tries++
		if tries &gt;= maxTriesPerEvent {
			glog.Errorf(&#34;Unable to write event &#39;%#v&#39; (retry limit exceeded!)&#34;, event)
			break
		}
		// Randomize the first sleep so that various clients won&#39;t all be
		// synced up if the master goes down.
		if tries == 1 {
			time.Sleep(time.Duration(float64(sleepDuration) * randGen.Float64()))
		} else {
			time.Sleep(sleepDuration)
		}
	}
}</code></pre>
<p><br></p>
<pre><code>// EventCorrelate filters, aggregates, counts, and de-duplicates all incoming events
func (c *EventCorrelator) EventCorrelate(newEvent *v1.Event) (*EventCorrelateResult, error) {
	if newEvent == nil {
		return nil, fmt.Errorf(&#34;event is nil&#34;)
	}
	// 1.先聚合。这里分为了两步，EventAggregate和eventObserve
	aggregateEvent, ckey := c.aggregator.EventAggregate(newEvent)
	observedEvent, patch, err := c.logger.eventObserve(aggregateEvent, ckey)
	
	// 2.通过filter函数，就是令牌桶算法判断是否有足够令牌可以够事件发送
	if c.filterFunc(observedEvent) {
		return &amp;EventCorrelateResult{Skip: true}, nil
	}
	return &amp;EventCorrelateResult{Event: observedEvent, Patch: patch}, err
}</code></pre>
<h4 id="3-1-事件聚合">3.1 事件聚合</h4>

<p>事件聚合分为了两步，EventAggregate和eventObserv。EventAggregate主要做了以下的事情：</p>

<p><strong>第一步</strong>，基于 event 构建 key。事件聚合的一个关键就是比较俩个事件是不是同一个类型的事件，如果是同一个类型的事件才可能聚合。这里构造的key就是用于判断是否是一类事件。</p>

<p>这里有来个key,一个是aggregateKey：<code>event.Source</code>, <code>event.InvolvedObject</code>, <code>event.Type</code> 和 <code>event.Reason</code>拼接而成</p>

<p>另一个是localKey：event.Message</p>

<p><strong>第二步</strong>， 通过 aggregateKey 从 cache 中获取缓存的 record ，或新建一个 record。</p>

<p><strong>第三步</strong>， 将第一步构建出的 localKey 加入 上一步得到的 record 的 localKeys，并更新缓存。record保存了同一 aggregateKey 下的事件的 message。所以就是 aggregateKey并且 localKey都相同的是一类的。</p>

<p><strong>第四步</strong>，若当前 record 的<code>record.localKeys</code>的长度小于 maxEvents（默认10），即同一 aggregateKey 下的 localKeys 数量没达到最大阈值，这代表不用对该事件进行聚合，直接返回传入的 event 不做需改。 如果超过maxEvents等等话，当<code>record.localKeys</code>长度大于maxEvents，说明此时在一段时间内同一 reason 产生的事件较多，这时会先从 localKeys 中删除最老的值（PopAny）以保证长度不会大于maxEvents，并对事件进行聚合，组装一个新的事件返回，并以 aggregateKey 作为 cache key 返回。</p>
<pre><code>/ EventAggregate checks if a similar event has been seen according to the
// aggregation configuration (max events, max interval, etc) and returns:
//
// - The (potentially modified) event that should be created
// - The cache key for the event, for correlation purposes. This will be set to
//   the full key for normal events, and to the result of
//   EventAggregatorMessageFunc for aggregate events.
func (e *EventAggregator) EventAggregate(newEvent *v1.Event) (*v1.Event, string) {
	now := metav1.NewTime(e.clock.Now())
	var record aggregateRecord
	
	// eventKey is the full cache key for this event
	eventKey := getEventKey(newEvent)
	// aggregateKey is for the aggregate event, if one is needed.
	// 1.这里的keyFunc就是EventAggregatorByReasonFunc
	aggregateKey, localKey := e.keyFunc(newEvent)

	// Do we have a record of similar events in our cache?
	e.Lock()
	defer e.Unlock()
	value, found := e.cache.Get(aggregateKey)
	if found {
		record = value.(aggregateRecord)
	}

	// Is the previous record too old? If so, make a fresh one. Note: if we didn&#39;t
	// find a similar record, its lastTimestamp will be the zero value, so we
	// create a new one in that case.
	maxInterval := time.Duration(e.maxIntervalInSeconds) * time.Second
	interval := now.Time.Sub(record.lastTimestamp.Time)
	if interval &gt; maxInterval {
		record = aggregateRecord{localKeys: sets.NewString()}
	}

	// Write the new event into the aggregation record and put it on the cache
	record.localKeys.Insert(localKey)
	record.lastTimestamp = now
	e.cache.Add(aggregateKey, record)

	// If we are not yet over the threshold for unique events, don&#39;t correlate them
	if uint(record.localKeys.Len()) &lt; e.maxEvents {
		return newEvent, eventKey
	}

	// do not grow our local key set any larger than max
	record.localKeys.PopAny()

	// create a new aggregate event, and return the aggregateKey as the cache key
	// (so that it can be overwritten.)
	eventCopy := &amp;v1.Event{
		ObjectMeta: metav1.ObjectMeta{
			Name:      fmt.Sprintf(&#34;%v.%x&#34;, newEvent.InvolvedObject.Name, now.UnixNano()),
			Namespace: newEvent.Namespace,
		},
		Count:          1,
		FirstTimestamp: now,
		InvolvedObject: newEvent.InvolvedObject,
		LastTimestamp:  now,
		Message:        e.messageFunc(newEvent),   //就是聚合后的mess会增加 (combined from similar events): 字段
		Type:           newEvent.Type,
		Reason:         newEvent.Reason,
		Source:         newEvent.Source,
	}
	return eventCopy, aggregateKey
}

// EventAggregratorByReasonMessageFunc returns an aggregate message by prefixing the incoming message
func EventAggregatorByReasonMessageFunc(event *v1.Event) string {
	return &#34;(combined from similar events): &#34; + event.Message
}

// EventAggregatorByReasonFunc aggregates events by exact match on event.Source, event.InvolvedObject, event.Type and event.Reason
func EventAggregatorByReasonFunc(event *v1.Event) (string, string) {
	return strings.Join([]string{
		event.Source.Component,
		event.Source.Host,
		event.InvolvedObject.Kind,
		event.InvolvedObject.Namespace,
		event.InvolvedObject.Name,
		string(event.InvolvedObject.UID),
		event.InvolvedObject.APIVersion,
		event.Type,
		event.Reason,
	},
		&#34;&#34;), event.Message
}</code></pre>
<p><br></p>

<p>eventObserve处理逻辑如下：</p>

<p>调用<code>e.lastEventObservationFromCache(key)</code>查询 cache，如果缓存不为空，那么要对事件 count+1，并进行 merge 生成 patch。
\最后将事件的 eventLog 加入缓存</p>
<pre><code>// eventObserve records an event, or updates an existing one if key is a cache hit
func (e *eventLogger) eventObserve(newEvent *v1.Event, key string) (*v1.Event, []byte, error) {
	var (
		patch []byte
		err   error
	)
	eventCopy := *newEvent
	event := &amp;eventCopy

	e.Lock()
	defer e.Unlock()

	// Check if there is an existing event we should update
	lastObservation := e.lastEventObservationFromCache(key)

	// If we found a result, prepare a patch
	if lastObservation.count &gt; 0 {
		// update the event based on the last observation so patch will work as desired
		event.Name = lastObservation.name
		event.ResourceVersion = lastObservation.resourceVersion
		event.FirstTimestamp = lastObservation.firstTimestamp
		event.Count = int32(lastObservation.count) + 1

		eventCopy2 := *event
		eventCopy2.Count = 0
		eventCopy2.LastTimestamp = metav1.NewTime(time.Unix(0, 0))
		eventCopy2.Message = &#34;&#34;

		newData, _ := json.Marshal(event)
		oldData, _ := json.Marshal(eventCopy2)
		patch, err = strategicpatch.CreateTwoWayMergePatch(oldData, newData, event)
	}

	// record our new observation
	e.cache.Add(
		key,
		eventLog{
			count:           uint(event.Count),
			firstTimestamp:  event.FirstTimestamp,
			name:            event.Name,
			resourceVersion: event.ResourceVersion,
		},
	)
	return event, patch, err
}</code></pre>
<p><br></p>

<h4 id="3-2-事件过滤-获取令牌">3.2 事件过滤/获取令牌</h4>

<p><strong>这里需要注意的是：如果当前没有足够的令牌给一个事件，这个事件并不会等待，而是直接跳过，这个就是造成apiserver没有收到event的根本原因</strong></p>

<p>令牌桶发送事件的步骤：</p>

<ol>
<li>根据事件获得对应的令牌桶。</li>
</ol>

<p>k8s中每一个对象都有一个令牌桶。一个pod就是一个对象，其实就是每个pod都有一个令牌桶存放在kubelet的缓存中。</p>

<p>如果当前对象没有令牌桶，这里会自动生成一个。</p>

<p>令牌桶的核心参数：qps: <sup>1</sup>&frasl;<sub>300</sub>, burst: 25，tokens,  durTime。令牌桶的核心参数说明:</p>

<p>qps: <sup>1</sup>&frasl;<sub>300</sub>  表示300秒产生一个令牌。</p>

<p>burst: 25 表示令牌桶的大小为25。</p>

<p>tokens表示上一次记录时还有多少令牌可用</p>

<p>durTime 表示距离上一次记录经过了多少事件</p>

<p><br></p>

<ol>
<li>根据令牌桶的四个核心参数，判断该event是否可用进行发送</li>
</ol>

<p>计算逻辑如下：</p>

<p>（1）得到这次需要发送事件的数量，count</p>

<p>（2）得到当前可用的令牌， curToken = tokens + durTime*qps</p>

<p>（3）如果count &lt;= curToken， 可以发送；否则就直接跳过。</p>

<p>主要调用链路如下：</p>
<pre><code>// Filter controls that a given source+object are not exceeding the allowed rate.
func (f *EventSourceObjectSpamFilter) Filter(event *v1.Event) bool {
	var record spamRecord

	// controls our cached information about this event (source+object)
	eventKey := getSpamKey(event)

	glog.Errorf(&#34;zoux-test eventKey is &#39;%#v&#39;&#34;, eventKey)
	// do we have a record of similar events in our cache?
	f.Lock()
	defer f.Unlock()
	value, found := f.cache.Get(eventKey)
	if found {
		record = value.(spamRecord)
		glog.Errorf(&#34;zoux-test found record.rateLimiter is &#39;%#v&#39;&#34;, record.rateLimiter, record.rateLimiter)
	}

	// verify we have a rate limiter for this record
	if record.rateLimiter == nil {
		record.rateLimiter = flowcontrol.NewTokenBucketRateLimiterWithClock(f.qps, f.burst, f.clock)
	}
	glog.Errorf(&#34;zoux-test record.rateLimiter is &#39;%#v&#39;&#34;, record.rateLimiter)

	// ensure we have available rate
	filter := !record.rateLimiter.TryAccept()

	glog.Errorf(&#34;zoux-test filter is &#39;%#v&#39;&#34;, filter)


	// update the cache
	f.cache.Add(eventKey, record)

	return filter
}</code></pre>
<h4 id="3-3-调用rest接口进行事件发送">3.3 调用rest接口进行事件发送</h4>

<p>这个依赖于第二步的判断，如果令牌桶没有可用的令牌，这个事件会被跳过。核心代码如下：</p>

<p>sink.Patch, sink.Create就是具体的发送函数。</p>
<pre><code>// recordEvent attempts to write event to a sink. It returns true if the event
// was successfully recorded or discarded, false if it should be retried.
// If updateExistingEvent is false, it creates a new event, otherwise it updates
// existing event.
func recordEvent(sink EventSink, event *v1.Event, patch []byte, updateExistingEvent bool, eventCorrelator *EventCorrelator) bool {
	var newEvent *v1.Event
	var err error
	if updateExistingEvent {
		glog.Errorf(&#34;zoux-test event &#39;%#v&#39; is exist&#34;,event)
		newEvent, err = sink.Patch(event, patch)
	}
	// Update can fail because the event may have been removed and it no longer exists.
	if !updateExistingEvent || (updateExistingEvent &amp;&amp; isKeyNotFoundError(err)) {
		// Making sure that ResourceVersion is empty on creation
		event.ResourceVersion = &#34;&#34;
		newEvent, err = sink.Create(event)
		glog.Errorf(&#34;zoux-test newEvent &#39;%#v&#39; , err is %v&#34;,newEvent,err)
	}
	if err == nil {
		// we need to update our event correlator with the server returned state to handle name/resourceversion
		eventCorrelator.UpdateState(newEvent)
		return true
	}


	// If we can&#39;t contact the server, then hold everything while we keep trying.
	// Otherwise, something about the event is malformed and we should abandon it.
	switch err.(type) {
	case *restclient.RequestConstructionError:
		// We will construct the request the same next time, so don&#39;t keep trying.
		glog.Errorf(&#34;Unable to construct event &#39;%#v&#39;: &#39;%v&#39; (will not retry!)&#34;, event, err)
		return true
	case *errors.StatusError:
		if errors.IsAlreadyExists(err) {
			glog.V(5).Infof(&#34;Server rejected event &#39;%#v&#39;: &#39;%v&#39; (will not retry!)&#34;, event, err)
		} else {
			glog.Errorf(&#34;Server rejected event &#39;%#v&#39;: &#39;%v&#39; (will not retry!)&#34;, event, err)
		}
		return true
	case *errors.UnexpectedObjectError:
		// We don&#39;t expect this; it implies the server&#39;s response didn&#39;t match a
		// known pattern. Go ahead and retry.
	default:
		// This case includes actual http transport errors. Go ahead and retry.
	}
	glog.Errorf(&#34;Unable to write event: &#39;%v&#39; (may retry after sleeping)&#34;, err)
	return false
}

// k8s.io/client-go/kubernetes/typed/core/v1/event_expansion.go
func (e *EventSinkImpl) Patch(event *v1.Event, data []byte) (*v1.Event, error) {
	return e.Interface.PatchWithEventNamespace(event, data)
}


// 通过rest接口发送了事件
// PatchWithEventNamespace modifies an existing event. It returns the copy of
// the event that the server returns, or an error. The namespace and name of the
// target event is deduced from the incompleteEvent. The namespace must either
// match this event client&#39;s namespace, or this event client must have been
// created with the &#34;&#34; namespace.
func (e *events) PatchWithEventNamespace(incompleteEvent *v1.Event, data []byte) (*v1.Event, error) {
	glog.Errorf(&#34;zoux-test v1 starting patch event in PatchWithEventNamespace&#34;)
	if e.ns != &#34;&#34; &amp;&amp; incompleteEvent.Namespace != e.ns {
		return nil, fmt.Errorf(&#34;can&#39;t patch an event with namespace &#39;%v&#39; in namespace &#39;%v&#39;&#34;, incompleteEvent.Namespace, e.ns)
	}
	result := &amp;v1.Event{}
	err := e.client.Patch(types.StrategicMergePatchType).
		NamespaceIfScoped(incompleteEvent.Namespace, len(incompleteEvent.Namespace) &gt; 0).
		Resource(&#34;events&#34;).
		Name(incompleteEvent.Name).
		Body(data).
		Do().
		Into(result)
	glog.Errorf(&#34;zoux-test v1 post event in PatchWithEventNamespace result is &#39;%#v&#39;&#34;, result)
	return result, err
}</code></pre>
<p><br></p>

<h3 id="4-有趣的现象">4. 有趣的现象</h3>

<p>基于上面的分析，可以看出来，令牌桶的qps非常低，那这样会不会出现某些情况下，大量的无用事件使用了令牌，导致有用的事件无令牌可用从而不能发送事件呢。答案是可以的。构造以下场景。</p>

<p>构造场景：创建一个pod, 该pod有10个容器（），并且某个容器会让pod OOM。</p>

<p>目的就是让pull ,create container等事件消耗令牌，然后后面的oom等事件因为没有令牌而被跳过。</p>

<p>pod yaml如下：</p>
<pre><code>apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  hostNetwork: true
  containers:
    - name: busbox
      image: polinux/stress
      imagePullPolicy: IfNotPresent
      resources:
        limits:
          cpu: 1
          memory: 200Mi
        requests:
          cpu: 1
          memory: 100Mi
      command: [&#34;stress&#34;]
      args: [&#34;--vm&#34;, &#34;1&#34;, &#34;--vm-bytes&#34;, &#34;3000M&#34;, &#34;--vm-hang&#34;, &#34;1&#34;]
    - name: busbox1
      image: busybox
      imagePullPolicy: IfNotPresent
      command:
        - sleep
        - &#34;36000&#34;
    - name: busbox2
      image: busybox
      imagePullPolicy: IfNotPresent
      command:
        - sleep
        - &#34;36000&#34;
    - name: busbox3
      image: busybox
      imagePullPolicy: IfNotPresent
      command:
        - sleep
        - &#34;36000&#34;
    - name: busbox4
      image: busybox
      imagePullPolicy: IfNotPresent
      command:
        - sleep
        - &#34;36000&#34;
    - name: busbox5
      image: busybox
      imagePullPolicy: IfNotPresent
      command:
        - sleep
        - &#34;36000&#34;
    - name: busbox6
      image: busybox
      imagePullPolicy: IfNotPresent
      command:
        - sleep
        - &#34;36000&#34;
    - name: busbox7
      image: busybox
      imagePullPolicy: IfNotPresent
      command:
        - sleep
        - &#34;36000&#34;
    - name: busbox8
      image: busybox
      imagePullPolicy: IfNotPresent
      command:
        - sleep
        - &#34;36000&#34;
    - name: busbox9
      image: busybox
      imagePullPolicy: IfNotPresent
      command:
        - sleep
        - &#34;36000&#34;</code></pre>
<p>创建pod的后，进行以下的观察（多开几个窗口同时观察）：</p>

<p>（1）观察pod的状态, 发现pod OOMKilled， CrashLoopBackOff</p>
<pre><code>root@cld-pmaster1-1699:/home/zouxiang# kubectl get pod -w


NAME    READY   STATUS      RESTARTS   AGE
nginx   9/10    OOMKilled   0          22s
nginx   9/10   OOMKilled   1     22s
nginx   9/10   CrashLoopBackOff   1     22s
nginx   10/10   Running   2     36s
nginx   9/10   OOMKilled   2     37s
nginx   9/10   CrashLoopBackOff   2     49s</code></pre>
<p>（2）kubectl describe pod nginx</p>

<p>这里只显示event，发现一个事情，oom的事件没有出现。</p>
<pre><code>Events:
  Type    Reason     Age   From                    Message
  ----    ------     ----  ----                    -------
  Normal  Scheduled  53s   default-scheduler       Successfully assigned default/nginx to 10.212.195.74
  Normal  Pulled     52s   kubelet, 10.212.195.74  Container image &#34;polinux/stress&#34; already present on machine
  Normal  Created    51s   kubelet, 10.212.195.74  Created container
  Normal  Started    51s   kubelet, 10.212.195.74  Started container
  Normal  Pulled     51s   kubelet, 10.212.195.74  Container image &#34;busybox&#34; already present on machine
  Normal  Created    50s   kubelet, 10.212.195.74  Created container
  Normal  Pulled     49s   kubelet, 10.212.195.74  Container image &#34;busybox&#34; already present on machine
  Normal  Started    49s   kubelet, 10.212.195.74  Started container
  Normal  Created    48s   kubelet, 10.212.195.74  Created container
  Normal  Started    47s   kubelet, 10.212.195.74  Started container
  Normal  Pulled     47s   kubelet, 10.212.195.74  Container image &#34;busybox&#34; already present on machine
  Normal  Created    47s   kubelet, 10.212.195.74  Created container
  Normal  Started    46s   kubelet, 10.212.195.74  Started container
  Normal  Pulled     46s   kubelet, 10.212.195.74  Container image &#34;busybox&#34; already present on machine
  Normal  Created    45s   kubelet, 10.212.195.74  Created container
  Normal  Started    44s   kubelet, 10.212.195.74  Started container
  Normal  Pulled     44s   kubelet, 10.212.195.74  Container image &#34;busybox&#34; already present on machine
  Normal  Created    44s   kubelet, 10.212.195.74  Created container
  Normal  Started    43s   kubelet, 10.212.195.74  Started container
  Normal  Pulled     43s   kubelet, 10.212.195.74  Container image &#34;busybox&#34; already present on machine
  Normal  Created    42s   kubelet, 10.212.195.74  Created container
  Normal  Started    41s   kubelet, 10.212.195.74  Started container
  Normal  Pulled     41s   kubelet, 10.212.195.74  Container image &#34;busybox&#34; already present on machine
  Normal  Created    41s   kubelet, 10.212.195.74  Created container
  Normal  Started    39s   kubelet, 10.212.195.74  Started container
  Normal  Pulled     39s   kubelet, 10.212.195.74  Container image &#34;busybox&#34; already present on machine</code></pre>
<p>（3）kubectl get event -w 也发现oom事件</p>
<pre><code>root@cld-pmaster1-1699:/home/zouxiang# kubectl get event -w


0s    Normal   Scheduled   Pod   Successfully assigned default/nginx to 10.212.195.74
0s    Normal   Pulled   Pod   Container image &#34;polinux/stress&#34; already present on machine
0s    Normal   Created   Pod   Created container
0s    Normal   Started   Pod   Started container
0s    Normal   Pulled   Pod   Container image &#34;busybox&#34; already present on machine
0s    Normal   Created   Pod   Created container
0s    Normal   Started   Pod   Started container
0s    Normal   Pulled   Pod   Container image &#34;busybox&#34; already present on machine
0s    Normal   Created   Pod   Created container
0s    Normal   Started   Pod   Started container
0s    Normal   Pulled   Pod   Container image &#34;busybox&#34; already present on machine
0s    Normal   Created   Pod   Created container
0s    Normal   Started   Pod   Started container
0s    Normal   Pulled   Pod   Container image &#34;busybox&#34; already present on machine
0s    Normal   Created   Pod   Created container
0s    Normal   Started   Pod   Started container
0s    Normal   Pulled   Pod   Container image &#34;busybox&#34; already present on machine
0s    Normal   Created   Pod   Created container
0s    Normal   Started   Pod   Started container
0s    Normal   Pulled   Pod   Container image &#34;busybox&#34; already present on machine
0s    Normal   Created   Pod   Created container
0s    Normal   Started   Pod   Started container
0s    Normal   Pulled   Pod   Container image &#34;busybox&#34; already present on machine
0s    Normal   Created   Pod   Created container
0s    Normal   Started   Pod   Started container
0s    Normal   Pulled   Pod   Container image &#34;busybox&#34; already present on machine</code></pre>
<p>（4）查看kubelet日志，这里我增加了很多自己的日志。具体可以参考2.4节中的recordToSink函数</p>
<pre><code>// 创建容器的日志被跳过了
E0626 21:21:31.605289   36267 event.go:140] zoux-test event &#39;&amp;v1.Event{TypeMeta:v1.TypeMeta{Kind:&#34;&#34;, APIVersion:&#34;&#34;}, ObjectMeta:v1.ObjectMeta{Name:&#34;nginx.168c247e91d19615&#34;, GenerateName:&#34;&#34;, Namespace:&#34;default&#34;, SelfLink:&#34;&#34;, UID:&#34;&#34;, ResourceVersion:&#34;&#34;, Generation:0, CreationTimestamp:v1.Time{Time:time.Time{wall:0x0, ext:0, loc:(*time.Location)(nil)}}, DeletionTimestamp:(*v1.Time)(nil), DeletionGracePeriodSeconds:(*int64)(nil), Labels:map[string]string(nil), Annotations:map[string]string(nil), OwnerReferences:[]v1.OwnerReference(nil), Initializers:(*v1.Initializers)(nil), Finalizers:[]string(nil), ClusterName:&#34;&#34;}, InvolvedObject:v1.ObjectReference{Kind:&#34;Pod&#34;, Namespace:&#34;default&#34;, Name:&#34;nginx&#34;, UID:&#34;570f873f-d681-11eb-921a-52540019dd70&#34;, APIVersion:&#34;v1&#34;, ResourceVersion:&#34;11565452&#34;, FieldPath:&#34;spec.containers{busbox}&#34;}, Reason:&#34;Created&#34;, Message:&#34;Created container&#34;, Source:v1.EventSource{Component:&#34;kubelet&#34;, Host:&#34;10.212.195.74&#34;}, FirstTimestamp:v1.Time{Time:time.Time{wall:0xc02de856e40cc815, ext:169113605992047, loc:(*time.Location)(0x65a7120)}}, LastTimestamp:v1.Time{Time:time.Time{wall:0xc02de856e40cc815, ext:169113605992047, loc:(*time.Location)(0x65a7120)}}, Count:1, Type:&#34;Normal&#34;, EventTime:v1.MicroTime{Time:time.Time{wall:0x0, ext:0, loc:(*time.Location)(nil)}}, Series:(*v1.EventSeries)(nil), Action:&#34;&#34;, Related:(*v1.ObjectReference)(nil), ReportingController:&#34;&#34;, ReportingInstance:&#34;&#34;}&#39; is Skipped

// Started container的事件也被跳过了
E0626 21:21:32.260935   36267 event.go:140] zoux-test event &#39;&amp;v1.Event{TypeMeta:v1.TypeMeta{Kind:&#34;&#34;, APIVersion:&#34;&#34;}, ObjectMeta:v1.ObjectMeta{Name:&#34;nginx.168c247eb8e6cfb1&#34;, GenerateName:&#34;&#34;, Namespace:&#34;default&#34;, SelfLink:&#34;&#34;, UID:&#34;&#34;, ResourceVersion:&#34;&#34;, Generation:0, CreationTimestamp:v1.Time{Time:time.Time{wall:0x0, ext:0, loc:(*time.Location)(nil)}}, DeletionTimestamp:(*v1.Time)(nil), DeletionGracePeriodSeconds:(*int64)(nil), Labels:map[string]string(nil), Annotations:map[string]string(nil), OwnerReferences:[]v1.OwnerReference(nil), Initializers:(*v1.Initializers)(nil), Finalizers:[]string(nil), ClusterName:&#34;&#34;}, InvolvedObject:v1.ObjectReference{Kind:&#34;Pod&#34;, Namespace:&#34;default&#34;, Name:&#34;nginx&#34;, UID:&#34;570f873f-d681-11eb-921a-52540019dd70&#34;, APIVersion:&#34;v1&#34;, ResourceVersion:&#34;11565452&#34;, FieldPath:&#34;spec.containers{busbox}&#34;}, Reason:&#34;Started&#34;, Message:&#34;Started container&#34;, Source:v1.EventSource{Component:&#34;kubelet&#34;, Host:&#34;10.212.195.74&#34;}, FirstTimestamp:v1.Time{Time:time.Time{wall:0xc02de8570f8737b1, ext:169114261694459, loc:(*time.Location)(0x65a7120)}}, LastTimestamp:v1.Time{Time:time.Time{wall:0xc02de8570f8737b1, ext:169114261694459, loc:(*time.Location)(0x65a7120)}}, Count:1, Type:&#34;Normal&#34;, EventTime:v1.MicroTime{Time:time.Time{wall:0x0, ext:0, loc:(*time.Location)(nil)}}, Series:(*v1.EventSeries)(nil), Action:&#34;&#34;, Related:(*v1.ObjectReference)(nil), ReportingController:&#34;&#34;, ReportingInstance:&#34;&#34;}&#39; is Skipped

// BackOff的事件也被跳过了
E0626 21:21:33.554220   36267 event.go:140] zoux-test event &#39;&amp;v1.Event{TypeMeta:v1.TypeMeta{Kind:&#34;&#34;, APIVersion:&#34;&#34;}, ObjectMeta:v1.ObjectMeta{Name:&#34;nginx.168c247f05fbd51f&#34;, GenerateName:&#34;&#34;, Namespace:&#34;default&#34;, SelfLink:&#34;&#34;, UID:&#34;&#34;, ResourceVersion:&#34;&#34;, Generation:0, CreationTimestamp:v1.Time{Time:time.Time{wall:0x0, ext:0, loc:(*time.Location)(nil)}}, DeletionTimestamp:(*v1.Time)(nil), DeletionGracePeriodSeconds:(*int64)(nil), Labels:map[string]string(nil), Annotations:map[string]string(nil), OwnerReferences:[]v1.OwnerReference(nil), Initializers:(*v1.Initializers)(nil), Finalizers:[]string(nil), ClusterName:&#34;&#34;}, InvolvedObject:v1.ObjectReference{Kind:&#34;Pod&#34;, Namespace:&#34;default&#34;, Name:&#34;nginx&#34;, UID:&#34;570f873f-d681-11eb-921a-52540019dd70&#34;, APIVersion:&#34;v1&#34;, ResourceVersion:&#34;11565452&#34;, FieldPath:&#34;spec.containers{busbox}&#34;}, Reason:&#34;BackOff&#34;, Message:&#34;Back-off restarting failed container&#34;, Source:v1.EventSource{Component:&#34;kubelet&#34;, Host:&#34;10.212.195.74&#34;}, FirstTimestamp:v1.Time{Time:time.Time{wall:0xc02de8576101731f, ext:169115554917743, loc:(*time.Location)(0x65a7120)}}, LastTimestamp:v1.Time{Time:time.Time{wall:0xc02de8576101731f, ext:169115554917743, loc:(*time.Location)(0x65a7120)}}, Count:1, Type:&#34;Warning&#34;, EventTime:v1.MicroTime{Time:time.Time{wall:0x0, ext:0, loc:(*time.Location)(nil)}}, Series:(*v1.EventSeries)(nil), Action:&#34;&#34;, Related:(*v1.ObjectReference)(nil), ReportingController:&#34;&#34;, ReportingInstance:&#34;&#34;}&#39; is Skipped</code></pre>
<p><strong>结论：</strong> 当前情况下，qps太小会导致某些事件上传不了apiserver。</p>

<p><br></p>

<h3 id="5-总结">5. 总结</h3>

<p>（1）分析了kubulet的事件处理机制。包括聚合和过滤等流程。这个不仅仅可以有利于自己对kubelet的了解，还可以借鉴这种处理的思想。</p>

<p>（2）过滤流程发现了一个很有趣的现象，这个在某些情况下是非常致命的。例如集群依赖event做一些重要的告警。这样重要的事件如果没有上传就回导致告警失败。</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/2021-6-26-k8s-event%E4%BB%8B%E7%BB%8D/">k8s event介绍</a></li>
        
        <li><a href="/post/2021-6-18-hpa-%E8%87%AA%E5%AE%9A%E4%B9%89metric-server/">自定义metric server</a></li>
        
        <li><a href="/post/2021-6-18-hpa%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">hpa 源码分析</a></li>
        
        <li><a href="/post/2019-12-15-k8s%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6/">k8s的基本组件</a></li>
        
        <li><a href="/post/2019-11-24-k8s%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-scheduler%E7%AC%94%E8%AE%B01/">k8s源码学习 - Scheduler笔记（1）</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='/tags/k8s'>k8s</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "zoux86/blog"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2021 <a href="https://zoux86.github.io/">zoux的博客 By zoux</a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zoux86.github.io/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zoux86.github.io/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zoux86.github.io/post/2021-7-17-k8s%E4%B8%AD%E4%BB%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E7%AD%96%E7%95%A5%E5%88%A0%E9%99%A4%E8%B5%84%E6%BA%90%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/" title="k8s中以不同的策略删除资源时发生了什么">k8s中以不同的策略删除资源时发生了什么</a>
    </li>
    
    <li>
        <a href="https://zoux86.github.io/post/2021-7-17-k8s-gc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="k8s gc controller源码分析">k8s gc controller源码分析</a>
    </li>
    
    <li>
        <a href="https://zoux86.github.io/post/2021-7-6-k8s-rs-controller-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="k8s rs controller源码分析">k8s rs controller源码分析</a>
    </li>
    
    <li>
        <a href="https://zoux86.github.io/post/2021-7-6-deployment-controller-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="k8s deploy controller源码分析">k8s deploy controller源码分析</a>
    </li>
    
    <li>
        <a href="https://zoux86.github.io/post/2020-6-26-kubelet%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/" title="kubelet事件处理机制详解">kubelet事件处理机制详解</a>
    </li>
    
    <li>
        <a href="https://zoux86.github.io/post/2021-6-26-k8s-event%E4%BB%8B%E7%BB%8D/" title="k8s event介绍">k8s event介绍</a>
    </li>
    
    <li>
        <a href="https://zoux86.github.io/post/2021-6-18-hpa-%E8%87%AA%E5%AE%9A%E4%B9%89metric-server/" title="自定义metric server">自定义metric server</a>
    </li>
    
    <li>
        <a href="https://zoux86.github.io/post/2021-6-18-hpa%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="hpa 源码分析">hpa 源码分析</a>
    </li>
    
    <li>
        <a href="https://zoux86.github.io/post/2019-12-15-k8s%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6/" title="k8s的基本组件">k8s的基本组件</a>
    </li>
    
    <li>
        <a href="https://zoux86.github.io/post/2019-12-10-go%E7%9A%84%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" title="go的各种类型转换">go的各种类型转换</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href='/categories/'>分类</a></h3>
<ul class="widget-list">
    
    <li><a href="https://zoux86.github.io/categories/2019%E6%A0%A1%E6%8B%9B/">2019校招 (17)</a></li>
    
    <li><a href="https://zoux86.github.io/categories/c&#43;&#43;/">C&#43;&#43; (7)</a></li>
    
    <li><a href="https://zoux86.github.io/categories/docker/">docker (2)</a></li>
    
    <li><a href="https://zoux86.github.io/categories/go/">go (1)</a></li>
    
    <li><a href="https://zoux86.github.io/categories/hadoop/">Hadoop (7)</a></li>
    
    <li><a href="https://zoux86.github.io/categories/k8s/">k8s (12)</a></li>
    
    <li><a href="https://zoux86.github.io/categories/kube-batch/">kube-batch (5)</a></li>
    
    <li><a href="https://zoux86.github.io/categories/kubeflow/">kubeflow (11)</a></li>
    
    <li><a href="https://zoux86.github.io/categories/volcano/">volcano (4)</a></li>
    
    <li><a href="https://zoux86.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F/">个人感悟 (2)</a></li>
    
    <li><a href="https://zoux86.github.io/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">环境搭建 (7)</a></li>
    
    <li><a href="https://zoux86.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题 (2)</a></li>
    
    <li><a href="https://zoux86.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记 (1)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/tags/'>标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zoux86.github.io/tags/c&#43;&#43;/">C&#43;&#43;</a>
    
    <a href="https://zoux86.github.io/tags/clean-code/">clean code</a>
    
    <a href="https://zoux86.github.io/tags/docker/">docker</a>
    
    <a href="https://zoux86.github.io/tags/go/">go</a>
    
    <a href="https://zoux86.github.io/tags/golang/">golang</a>
    
    <a href="https://zoux86.github.io/tags/hadoop/">Hadoop</a>
    
    <a href="https://zoux86.github.io/tags/k8s/">k8s</a>
    
    <a href="https://zoux86.github.io/tags/kube-batch/">kube-batch</a>
    
    <a href="https://zoux86.github.io/tags/kubeflow/">kubeflow</a>
    
    <a href="https://zoux86.github.io/tags/tf-operator/">tf-operator</a>
    
    <a href="https://zoux86.github.io/tags/tfjob/">tfjob</a>
    
    <a href="https://zoux86.github.io/tags/ubuntu/">ubuntu</a>
    
    <a href="https://zoux86.github.io/tags/volcano/">volcano</a>
    
    <a href="https://zoux86.github.io/tags/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/">代码整洁之道</a>
    
    <a href="https://zoux86.github.io/tags/%E5%8D%9A%E5%AE%A2/">博客</a>
    
    <a href="https://zoux86.github.io/tags/%E6%84%9F%E6%82%9F/">感悟</a>
    
    <a href="https://zoux86.github.io/tags/%E6%A0%A1%E6%8B%9B/">校招</a>
    
    <a href="https://zoux86.github.io/tags/%E6%BA%90%E7%A0%81/">源码</a>
    
    <a href="https://zoux86.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">环境搭建</a>
    
    <a href="https://zoux86.github.io/tags/%E7%AC%94%E8%AE%B0/">笔记</a>
    
    <a href="https://zoux86.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a>
    
    <a href="https://zoux86.github.io/tags/%E8%B0%83%E5%BA%A6/">调度</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">友情链接</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://www.jianshu.com/u/305d8226ced4" title="个人简书主页">个人简书主页</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zoux86.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>